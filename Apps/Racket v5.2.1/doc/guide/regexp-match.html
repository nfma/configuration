<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>9.2&nbsp;Matching Regexp Patterns</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="../racket.css" title="default" /><link rel="stylesheet" type="text/css" href="../scribble-style.css" title="default" /><script type="text/javascript" src="../scribble-common.js"></script></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x"><span style="font-weight: bold">The Racket Guide</span></a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="intro.html" class="tocviewlink" pltdoc="x">Welcome to Racket</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="to-scheme.html" class="tocviewlink" pltdoc="x">Racket Essentials</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="datatypes.html" class="tocviewlink" pltdoc="x">Built-<wbr></wbr>In Datatypes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="scheme-forms.html" class="tocviewlink" pltdoc="x">Expressions and Definitions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="define-struct.html" class="tocviewlink" pltdoc="x">Programmer-<wbr></wbr>Defined Datatypes</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="modules.html" class="tocviewlink" pltdoc="x">Modules</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="contracts.html" class="tocviewlink" pltdoc="x">Contracts</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="i_o.html" class="tocviewlink" pltdoc="x">Input and Output</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="regexp.html" class="tocviewselflink" pltdoc="x">Regular Expressions</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="control.html" class="tocviewlink" pltdoc="x">Exceptions and Control</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="for.html" class="tocviewlink" pltdoc="x">Iterations and Comprehensions</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="match.html" class="tocviewlink" pltdoc="x">Pattern Matching</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="classes.html" class="tocviewlink" pltdoc="x">Classes and Objects</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="units.html" class="tocviewlink" pltdoc="x">Units (Components)</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="reflection.html" class="tocviewlink" pltdoc="x">Reflection and Dynamic Evaluation</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="macros.html" class="tocviewlink" pltdoc="x">Macros</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="languages.html" class="tocviewlink" pltdoc="x">Creating Languages</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="performance.html" class="tocviewlink" pltdoc="x">Performance</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="running.html" class="tocviewlink" pltdoc="x">Running and Creating Executables</a></td></tr><tr><td align="right">20&nbsp;</td><td><a href="More_Libraries.html" class="tocviewlink" pltdoc="x">More Libraries</a></td></tr><tr><td align="right">21&nbsp;</td><td><a href="dialects.html" class="tocviewlink" pltdoc="x">Dialects of Racket and Scheme</a></td></tr><tr><td align="right">22&nbsp;</td><td><a href="other-editors.html" class="tocviewlink" pltdoc="x">Command-<wbr></wbr>Line Tools and Your Editor of Choice</a></td></tr><tr><td align="right"></td><td><a href="doc-bibliography.html" class="tocviewlink" pltdoc="x">Bibliography</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td>9&nbsp;</td><td><a href="regexp.html" class="tocviewlink" pltdoc="x">Regular Expressions</a></td></tr></table><div class="tocviewsublistbottom" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">9.1&nbsp;</td><td><a href="regexp-intro.html" class="tocviewlink" pltdoc="x">Writing Regexp Patterns</a></td></tr><tr><td align="right">9.2&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Matching Regexp Patterns</a></td></tr><tr><td align="right">9.3&nbsp;</td><td><a href="regexp-assert.html" class="tocviewlink" pltdoc="x">Basic Assertions</a></td></tr><tr><td align="right">9.4&nbsp;</td><td><a href="regexp-chars.html" class="tocviewlink" pltdoc="x">Characters and Character Classes</a></td></tr><tr><td align="right">9.5&nbsp;</td><td><a href="regexp-quant.html" class="tocviewlink" pltdoc="x">Quantifiers</a></td></tr><tr><td align="right">9.6&nbsp;</td><td><a href="regexp-clusters.html" class="tocviewlink" pltdoc="x">Clusters</a></td></tr><tr><td align="right">9.7&nbsp;</td><td><a href="regexp-alternation.html" class="tocviewlink" pltdoc="x">Alternation</a></td></tr><tr><td align="right">9.8&nbsp;</td><td><a href="Backtracking.html" class="tocviewlink" pltdoc="x">Backtracking</a></td></tr><tr><td align="right">9.9&nbsp;</td><td><a href="Looking_Ahead_and_Behind.html" class="tocviewlink" pltdoc="x">Looking Ahead and Behind</a></td></tr><tr><td align="right">9.10&nbsp;</td><td><a href="An_Extended_Example.html" class="tocviewlink" pltdoc="x">An Extended Example</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.2.1&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.2.1&quot;);">top</a></span><span class="navright"><a href="regexp-intro.html" title="backward to &quot;9.1 Writing Regexp Patterns&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="regexp.html" title="up to &quot;9 Regular Expressions&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="regexp-assert.html" title="forward to &quot;9.3 Basic Assertions&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>9.2<tt>&nbsp;</tt><a name="(part._regexp-match)"></a>Matching Regexp Patterns</h4><p>The <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span> function takes a <a href="regexp.html#(tech._regexp)" class="techoutside" pltdoc="x"><span class="techinside">regexp</span></a>
pattern and a <a href="regexp.html#(tech._text._string)" class="techoutside" pltdoc="x"><span class="techinside">text string</span></a>, and it returns a match if the regexp
matches (some part of) the <a href="regexp.html#(tech._text._string)" class="techoutside" pltdoc="x"><span class="techinside">text string</span></a>, or <span class="RktVal">#f</span> if the regexp
did not match the string. A successful match produces a list of
<a name="(tech._index._pair)"></a><span style="font-style: italic">index pairs</span>.</p><p><table cellspacing="0" class="RktBlk"><tr><td><p>Examples:</p></td></tr><tr><td><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"brain"</span><span class="hspace">&nbsp;</span><span class="RktVal">"bird"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"needle"</span><span class="hspace">&nbsp;</span><span class="RktVal">"hay needle stack"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((4 . 10))</span></p></td></tr></table></blockquote></td></tr></table></p><p>In the second example, the integers <span class="RktVal">4</span> and <span class="RktVal">10</span>
identify the substring that was matched. The <span class="RktVal">4</span> is the
starting (inclusive) index, and <span class="RktVal">10</span> the ending (exclusive)
index of the matching substring:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/strings.html#(def._((quote._~23~25kernel)._substring))" class="RktValLink" pltdoc="x">substring</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hay needle stack"</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"needle"</span></p></td></tr></table></blockquote><p>In this first example, <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span>&rsquo;s return list
contains only one index pair, and that pair represents the entire
substring matched by the regexp.  When we discuss <a href="regexp-clusters.html#(tech._subpattern)" class="techoutside" pltdoc="x"><span class="techinside">subpatterns</span></a>
later, we will see how a single match operation can yield a list of
<a href="regexp-clusters.html#(tech._submatch)" class="techoutside" pltdoc="x"><span class="techinside">submatch</span></a>es.</p><p>The <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span> function takes optional third and
fourth arguments that specify the indices of the <a href="regexp.html#(tech._text._string)" class="techoutside" pltdoc="x"><span class="techinside">text string</span></a> within
which the matching should take place.</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"needle"</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;</span><span class="RktVal">"his needle stack -- my needle stack -- her needle stack"</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;</span><span class="RktVal">20</span><span class="hspace">&nbsp;</span><span class="RktVal">39</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'((23 . 29))</span></p></td></tr></table></blockquote><p>Note that the returned indices are still reckoned relative to the full
<a href="regexp.html#(tech._text._string)" class="techoutside" pltdoc="x"><span class="techinside">text string</span></a>.</p><p>The <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" class="RktValLink" pltdoc="x">regexp-match</a></span> function is like
<span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span>, but instead of returning index pairs,
it returns the matching substrings:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" class="RktValLink" pltdoc="x">regexp-match</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"brain"</span><span class="hspace">&nbsp;</span><span class="RktVal">"bird"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" class="RktValLink" pltdoc="x">regexp-match</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"needle"</span><span class="hspace">&nbsp;</span><span class="RktVal">"hay needle stack"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'("needle")</span></p></td></tr></table></blockquote><p>When <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" class="RktValLink" pltdoc="x">regexp-match</a></span> is used with byte-string regexp, the result
is a matching byte substring:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" class="RktValLink" pltdoc="x">regexp-match</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx#"needle"</span><span class="hspace">&nbsp;</span><span class="RktVal">#"hay needle stack"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(#"needle")</span></p></td></tr></table></blockquote><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>A byte-string regexp can be applied to a string, and a
string regexp can be applied to a byte string. In both
cases, the result is a byte string. Internally, all
regexp matching is in terms of bytes, and a string regexp
is expanded to a regexp that matches UTF-8 encodings of
characters. For maximum efficiency, use byte-string
matching instead of string, since matching bytes directly
avoids UTF-8 encodings.</p></blockquote></blockquote></blockquote><p>If you have data that is in a port, there&rsquo;s no need to first read it
into a string. Functions like <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" class="RktValLink" pltdoc="x">regexp-match</a></span> can match on the
port directly:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/define.html#(form._((quote._~23~25kernel)._define-values))" class="RktStxLink" pltdoc="x">define-values</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">i</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/pipeports.html#(def._((quote._~23~25kernel)._make-pipe))" class="RktValLink" pltdoc="x">make-pipe</a></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0"><tr><td></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/Writing.html#(def._((quote._~23~25kernel)._write))" class="RktValLink" pltdoc="x">write</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"hay needle stack"</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0"><tr><td></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/port-ops.html#(def._((quote._~23~25kernel)._close-output-port))" class="RktValLink" pltdoc="x">close-output-port</a></span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0"><tr><td></td></tr></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" class="RktValLink" pltdoc="x">regexp-match</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx#"needle"</span><span class="hspace">&nbsp;</span><span class="RktSym">i</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(#"needle")</span></p></td></tr></table></blockquote><p>The <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match~3f))" class="RktValLink" pltdoc="x">regexp-match?</a></span> function is like
<span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match-positions))" class="RktValLink" pltdoc="x">regexp-match-positions</a></span>, but simply returns a boolean
indicating whether the match succeeded:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match~3f))" class="RktValLink" pltdoc="x">regexp-match?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"brain"</span><span class="hspace">&nbsp;</span><span class="RktVal">"bird"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match~3f))" class="RktValLink" pltdoc="x">regexp-match?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"needle"</span><span class="hspace">&nbsp;</span><span class="RktVal">"hay needle stack"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr></table></blockquote><p>The <span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-split))" class="RktValLink" pltdoc="x">regexp-split</a></span> function takes two arguments, a
<a href="regexp.html#(tech._regexp)" class="techoutside" pltdoc="x"><span class="techinside">regexp</span></a> pattern and a text string, and it returns a list of
substrings of the text string; the pattern identifies the delimiter
separating the substrings.</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-split))" class="RktValLink" pltdoc="x">regexp-split</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx":"</span><span class="hspace">&nbsp;</span><span class="RktVal">"/bin:/usr/bin:/usr/bin/X11:/usr/local/bin"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'("/bin" "/usr/bin" "/usr/bin/X11" "/usr/local/bin")</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-split))" class="RktValLink" pltdoc="x">regexp-split</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx" "</span><span class="hspace">&nbsp;</span><span class="RktVal">"pea soup"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'("pea" "soup")</span></p></td></tr></table></blockquote><p>If the first argument matches empty strings, then the list of all the
single-character substrings is returned.</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-split))" class="RktValLink" pltdoc="x">regexp-split</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx""</span><span class="hspace">&nbsp;</span><span class="RktVal">"smithereens"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'("" "s" "m" "i" "t" "h" "e" "r" "e" "e" "n" "s" "")</span></p></td></tr></table></blockquote><p>Thus, to identify one-or-more spaces as the delimiter, take care to
use the regexp <span class="RktVal">#rx" +"</span>, not <span class="RktVal">#rx" *"</span>.</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-split))" class="RktValLink" pltdoc="x">regexp-split</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx" +"</span><span class="hspace">&nbsp;</span><span class="RktVal">"split pea</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">soup"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'("split" "pea" "soup")</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-split))" class="RktValLink" pltdoc="x">regexp-split</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx" *"</span><span class="hspace">&nbsp;</span><span class="RktVal">"split pea</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">soup"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'("" "s" "p" "l" "i" "t" "" "p" "e" "a" "" "s" "o" "u" "p" "")</span></p></td></tr></table></blockquote><p>The <span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-replace))" class="RktValLink" pltdoc="x">regexp-replace</a></span> function replaces the matched portion of
the text string by another string.  The first argument is the pattern,
the second the text string, and the third is either the string to be
inserted or a procedure to convert matches to the insert string.</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-replace))" class="RktValLink" pltdoc="x">regexp-replace</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"te"</span><span class="hspace">&nbsp;</span><span class="RktVal">"liberte"</span><span class="hspace">&nbsp;</span><span class="RktVal">"ty"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"liberty"</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((quote._~23~25kernel)._regexp-replace))" class="RktValLink" pltdoc="x">regexp-replace</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"."</span><span class="hspace">&nbsp;</span><span class="RktVal">"racket"</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/strings.html#(def._((quote._~23~25kernel)._string-upcase))" class="RktValLink" pltdoc="x">string-upcase</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"Racket"</span></p></td></tr></table></blockquote><p>If the pattern doesn&rsquo;t occur in the text string, the returned string
is identical to the text string.</p><p>The <span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-replace*))" class="RktValLink" pltdoc="x">regexp-replace*</a></span> function replaces <span style="font-style: italic">all</span> matches in
the text string by the insert string:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-replace*))" class="RktValLink" pltdoc="x">regexp-replace*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"te"</span><span class="hspace">&nbsp;</span><span class="RktVal">"liberte egalite fraternite"</span><span class="hspace">&nbsp;</span><span class="RktVal">"ty"</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"liberty egality fratyrnity"</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="../reference/regexp.html#(def._((lib._racket/private/base..rkt)._regexp-replace*))" class="RktValLink" pltdoc="x">regexp-replace*</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#rx"[ds]"</span><span class="hspace">&nbsp;</span><span class="RktVal">"drracket"</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="../reference/strings.html#(def._((quote._~23~25kernel)._string-upcase))" class="RktValLink" pltdoc="x">string-upcase</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">"Drracket"</span></p></td></tr></table></blockquote><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.2.1&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.2.1&quot;);">top</a></span><span class="navright"><a href="regexp-intro.html" title="backward to &quot;9.1 Writing Regexp Patterns&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="regexp.html" title="up to &quot;9 Regular Expressions&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="regexp-assert.html" title="forward to &quot;9.3 Basic Assertions&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>