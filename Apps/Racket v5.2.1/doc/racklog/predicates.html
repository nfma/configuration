<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>2&nbsp;Predicates</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="../racket.css" title="default" /><link rel="stylesheet" type="text/css" href="../scribble-style.css" title="default" /><script type="text/javascript" src="../scribble-common.js"></script></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" pltdoc="x">Racklog:<span class="mywbr"> </span> Prolog-<wbr></wbr>Style Logic Programming</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="simple.html" class="tocviewlink" pltdoc="x">Simple Goals and Queries</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Predicates</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="racket-w-logic.html" class="tocviewlink" pltdoc="x">Using Conventional Racket Expressions in Racklog</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="backtracking.html" class="tocviewlink" pltdoc="x">Backtracking</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="unification.html" class="tocviewlink" pltdoc="x">Unification</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="and-or.html" class="tocviewlink" pltdoc="x">Conjuctions and Disjunctions</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="lv-manip.html" class="tocviewlink" pltdoc="x">Manipulating Racklog Variables</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="cut.html" class="tocviewlink" pltdoc="x">The Cut (<span class="RktSym"><span class="RktStxLink">!</span></span>)</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="set-of.html" class="tocviewlink" pltdoc="x">Set Predicates</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Racklog_Module_Language.html" class="tocviewlink" pltdoc="x">Racklog Module Language</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="glossary.html" class="tocviewlink" pltdoc="x">Glossary of Racklog Primitives</a></td></tr><tr><td align="right"></td><td><a href="doc-bibliography.html" class="tocviewlink" pltdoc="x">Bibliography</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="" class="tocviewselflink" pltdoc="x">Predicates</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="#(part._facts)" class="tocviewlink" pltdoc="x">Predicates Introducing Facts</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="#(part._rules)" class="tocviewlink" pltdoc="x">Predicates with Rules</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="#(part._solving-goals)" class="tocviewlink" pltdoc="x">Solving Goals</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="#(part._assert)" class="tocviewlink" pltdoc="x">Asserting Extra Clauses</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="#(part._local-vars)" class="tocviewlink" pltdoc="x">Local Variables</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#(part._facts)" class="tocsubseclink" pltdoc="x">Predicates Introducing Facts</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#(part._rules)" class="tocsubseclink" pltdoc="x">Predicates with Rules</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#(part._solving-goals)" class="tocsubseclink" pltdoc="x">Solving Goals</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#(part._assert)" class="tocsubseclink" pltdoc="x">Asserting Extra Clauses</a></td></tr><tr><td><span class="tocsublinknumber">2.5<tt>&nbsp;</tt></span><a href="#(part._local-vars)" class="tocsubseclink" pltdoc="x">Local Variables</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.2.1&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.2.1&quot;);">top</a></span><span class="navright"><a href="simple.html" title="backward to &quot;1 Simple Goals and Queries&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Racklog: Prolog-Style Logic Programming&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="racket-w-logic.html" title="forward to &quot;3 Using Conventional Racket Expressions in Racklog&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>2<tt>&nbsp;</tt><a name="(part._predicates)"></a>Predicates</h3><p>More interesting goals are created by applying a special
kind of Racklog object called a <span style="font-style: italic">predicate</span> (or
<span style="font-style: italic">relation</span>) to other
Racklog objects.  Racklog comes with some primitive
predicates, such as the arithmetic operators
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3d~3a~3d))" class="RktValLink" pltdoc="x">%=:=</a></span> and <span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3c))" class="RktValLink" pltdoc="x">%&lt;</a></span>,
standing for arithmetic &ldquo;equal&rdquo; and &ldquo;less than&rdquo;
respectively.  For example, the following are some goals
involving these predicates:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3d~3a~3d))" class="RktValLink" pltdoc="x">%=:=</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3c))" class="RktValLink" pltdoc="x">%&lt;</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3d~3a~3d))" class="RktValLink" pltdoc="x">%=:=</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3c))" class="RktValLink" pltdoc="x">%&lt;</a></span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr></table></blockquote><p>Other arithmetic predicates are
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3e))" class="RktValLink" pltdoc="x">%&gt;</a></span> (&ldquo;greater than&rdquo;),
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3c~3d))" class="RktValLink" pltdoc="x">%&lt;=</a></span> (&ldquo;less than or equal&rdquo;),
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3e~3d))" class="RktValLink" pltdoc="x">%&gt;=</a></span> (&ldquo;greater than or equal&rdquo;), and
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25~3d/~3d))" class="RktValLink" pltdoc="x">%=/=</a></span> (&ldquo;not equal&rdquo;).</p><p>Racklog predicates are not to be confused with conventional
Racket predicates (such as <span class="RktSym"><a href="../reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3c))" class="RktValLink" pltdoc="x">&lt;</a></span> and <span class="RktSym"><a href="../reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3d))" class="RktValLink" pltdoc="x">=</a></span>).  Racklog
predicates, when applied to arguments, produce goals
that
may either succeed or fail.  Racket predicates, when applied
to arguments, yield a boolean value.  Henceforth, we will
use the term &ldquo;predicate&rdquo; to mean Racklog predicates.
Conventional predicates will be explicitly called &ldquo;Racket
predicates&rdquo;.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._facts)"></a>Predicates Introducing Facts</h4><p>Users can create their own predicates using the Racklog form
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span>.  For example, let&rsquo;s
define the predicate <span class="RktSym">%knows</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="../reference/define.html#(form._((lib._racket/private/base..rkt)._define))" class="RktStxLink" pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">%knows</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Racket</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Prolog</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Prolog</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Telemachus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Telemachus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">calculus</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>The expression has the expected meaning.  Each
<span style="font-style: italic">clause</span> in the <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span> establishes a <span style="font-style: italic">fact</span>:
Odysseus
knows TeX, Telemachus knows calculus, &amp;c.  In general, if we
apply the predicate to the arguments in any one of its
clauses, we will get a successful goal.  Thus, since
<span class="RktSym">%knows</span> has a clause that reads
<span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span><span class="RktPn">]</span>, the goal
<span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span>
will be true.</p><p>We can now get answers for the following types of queries:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Telemachus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Racket</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr></table></blockquote><h4>2.2<tt>&nbsp;</tt><a name="(part._rules)"></a>Predicates with Rules</h4><p>Predicates can be more complicated than the above bald
recitation of facts.  The predicate clauses can be <span style="font-style: italic">rules</span>, eg,</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="../reference/define.html#(form._((lib._racket/private/base..rkt)._define))" class="RktStxLink" pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">%computer-literate</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">person</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">person</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">person</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Racket</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">person</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">person</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">person</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Prolog</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>This defines the predicate
<span class="RktSym">%computer-literate</span> in
terms of the predicate <span class="RktSym">%knows</span>.  In effect, a person is
defined as computer-literate if they know TeX and
Racket, <span style="font-style: italic">or</span> TeX and Prolog.</p><p>Note that this use of
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span> employs a local <span style="font-style: italic">logic variable</span> called <span class="RktVar">person</span>.
In general, a <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span>-expression can have a list of symbols
as its second subform.  These name new logic variables that
can be used within the body of the <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span>.</p><p>The following query can now be answered:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%computer-literate</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr></table></blockquote><p>Since Penelope knows TeX and Prolog, she is computer-literate.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._solving-goals)"></a>Solving Goals</h4><p>The above queries are yes/no questions.  Racklog programming
allows more: We can formulate a goal with <span style="font-style: italic">uninstantiated</span>
logic variables and then ask the querying process to
provide, if possible, values for these variables that cause
the goal to succeed.  For instance, the query:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">what</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'((what . TeX))</span></p></td></tr></table></blockquote><p>asks for an instantiation of the logic variable <span class="RktVar">what</span>
that satisfies the goal <span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="stt"> </span><span class="RktSym">what</span><span class="RktPn">)</span>.
In other words, we are asking, &ldquo;What does Odysseus know?&rdquo;</p><p>Note that this use of <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span> &#8212;<wbr></wbr> like <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span>
in the definition of <span class="RktSym">%computer-literate</span> &#8212;<wbr></wbr>
uses a local logic
variable, <span class="RktVar">what</span>.  In general, the second subform of
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span> can be a list of local logic variables.  The
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span>-query returns an answer that is a list of
bindings, one for each logic variable mentioned in its
second subform.  Thus,</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">what</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'((what . TeX))</span></p></td></tr></table></blockquote><p>But that is not all that wily Odysseus knows.  Racklog
provides a zero-argument procedure (&ldquo;thunk&rdquo;) called
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span>
that <span style="font-style: italic">retries</span> the goal in the last
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span>-query for a different solution.</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((what . Racket))</span></p></td></tr></table></blockquote><p>We can keep pumping for more solutions:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((what . Prolog))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((what . Penelope))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr></table></blockquote><p>The final <span class="RktVal">#f</span> shows that there are no more
solutions.  This is because there are no more clauses in the
<span class="RktSym">%knows</span> predicate that list Odysseus as knowing anything
else.</p><h4>2.4<tt>&nbsp;</tt><a name="(part._assert)"></a>Asserting Extra Clauses</h4><p>We can add more clauses to a predicate after it has already
been defined with a <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span>.  Racklog provides the
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span> form for this purpose.  Eg,</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span><span class="hspace">&nbsp;</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">archery</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote><p>tacks on a new clause at the end of the existing clauses
of the <span class="RktSym">%knows</span>
predicate.  Now, the query:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">what</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'((what . TeX))</span></p></td></tr></table></blockquote><p>gives TeX, Racket, Prolog, and Penelope, as before, but
a subsequent <span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span><span class="RktPn">)</span> yields a new result:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'((what . archery))</span></p></td></tr></table></blockquote><p>The Racklog form <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert-after!))" class="RktStxLink" pltdoc="x">%assert-after!</a></span> is similar to <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span> but
adds clauses <span style="font-style: italic">before</span> any of the current clauses.</p><p>Both <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span> and <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert-after!))" class="RktStxLink" pltdoc="x">%assert-after!</a></span> assume that the variable
they are adding to already names a predicate (presumably
defined using <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span>).
In order to allow defining a predicate entirely through
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span>s,  Racklog provides an empty predicate value
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25empty-rel))" class="RktValLink" pltdoc="x">%empty-rel</a></span>.  <span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25empty-rel))" class="RktValLink" pltdoc="x">%empty-rel</a></span> takes any number of arguments
and always fails.  A typical use of the
<span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25empty-rel))" class="RktValLink" pltdoc="x">%empty-rel</a></span> and <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span> combination:</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="../reference/define.html#(form._((lib._racket/private/base..rkt)._define))" class="RktStxLink" pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">%parent</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25empty-rel))" class="RktValLink" pltdoc="x">%empty-rel</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span><span class="hspace">&nbsp;</span><span class="RktSym">%parent</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Laertes</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25assert!))" class="RktStxLink" pltdoc="x">%assert!</a></span><span class="hspace">&nbsp;</span><span class="RktSym">%parent</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Telemachus</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Telemachus</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></table></blockquote><p>(Racklog does not provide a predicate for <span style="font-style: italic">retracting</span>
assertions, since we can keep track of older versions of
predicates using conventional Racket features (<span class="RktSym"><a href="../reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" class="RktStxLink" pltdoc="x">let</a></span> and <span class="RktSym"><a href="../reference/set_.html#(form._((quote._~23~25kernel)._set!))" class="RktStxLink" pltdoc="x">set!</a></span>).)</p><h4>2.5<tt>&nbsp;</tt><a name="(part._local-vars)"></a>Local Variables</h4><p>The local logic variables of <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span>- and
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span>-expressions are in reality introduced by the
Racklog syntactic form called <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25let))" class="RktStxLink" pltdoc="x">%let</a></span>.  (<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25rel))" class="RktStxLink" pltdoc="x">%rel</a></span> and
<span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span> are macros written using <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25let))" class="RktStxLink" pltdoc="x">%let</a></span>.)</p><p><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25let))" class="RktStxLink" pltdoc="x">%let</a></span> introduces new lexically scoped logic variables.
Supposing, instead of</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">what</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'((what . TeX))</span></p></td></tr></table></blockquote><p>we had asked</p><blockquote class="SCodeFlow"><table cellspacing="0" class="RktBlk"><tr><td><table cellspacing="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25let))" class="RktStxLink" pltdoc="x">%let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">what</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Odysseus</span><span class="hspace">&nbsp;</span><span class="RktSym">what</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr></table></blockquote><p>This query, too, succeeds five times, since
Odysseus knows five things.  However, <span class="RktSym"><a href="glossary.html#(form._((lib._racklog/main..rkt)._~25which))" class="RktStxLink" pltdoc="x">%which</a></span> emits
bindings only for the local variables that <span style="font-style: italic">it</span>
introduces.  Thus, this query emits <span class="RktRes">()</span> five times before
<span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#(def._((lib._racklog/main..rkt)._~25more))" class="RktValLink" pltdoc="x">%more</a></span><span class="RktPn">)</span> finally returns <span class="RktVal">#f</span>.</p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="...search manuals..." title="Enter a search string to search the manuals" onkeypress="return DoSearchKey(event, this, &quot;5.2.1&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;...search manuals...&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;...search manuals...&quot;; }" /></form>&nbsp;&nbsp;<a href="../index.html" title="up to the documentation top" pltdoc="x" onclick="return GotoPLTRoot(&quot;5.2.1&quot;);">top</a></span><span class="navright"><a href="simple.html" title="backward to &quot;1 Simple Goals and Queries&quot;" pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Racklog: Prolog-Style Logic Programming&quot;" pltdoc="x">up</a>&nbsp;&nbsp;<a href="racket-w-logic.html" title="forward to &quot;3 Using Conventional Racket Expressions in Racklog&quot;" pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>